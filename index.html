<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu de la Vie - Ordinateur Fonctionnel</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        #game {
            display: grid;
            grid-template-columns: repeat(100, 6px);
            grid-template-rows: repeat(100, 6px);
            gap: 1px;
            margin-bottom: 20px;
            user-select: none; /* Empêche la sélection de texte lors du glissement */
            border: 1px solid #ccc;
        }
        .cell {
            width: 6px;
            height: 6px;
            background-color: #fff;
            border: 1px solid #ddd;
            cursor: pointer;
        }
        .alive {
            background-color: #000;
        }
        #controls {
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div id="game"></div>
    <div id="controls">
        <button id="startPauseButton">Démarrer</button>
        <button id="clearButton">Effacer</button>
        <button id="resetButton">Réinitialiser Ordinateur</button>
    </div>

    <script>
        const rows = 100;
        const cols = 100;
        const gameElement = document.getElementById('game');
        const startPauseButton = document.getElementById('startPauseButton');
        const clearButton = document.getElementById('clearButton');
        const resetButton = document.getElementById('resetButton');
        let grid = Array.from({ length: rows }, () => Array(cols).fill(0));
        let running = false;
        let intervalId;

        let isMouseDown = false;
        let toggleState = 1; // 1 pour activer, 0 pour désactiver

        // Créer la grille dans le DOM
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                const cellElement = document.createElement('div');
                cellElement.classList.add('cell');
                
                // Événements pour cliquer et glisser
                cellElement.addEventListener('mousedown', (e) => {
                    e.preventDefault(); // Empêche la sélection de texte
                    isMouseDown = true;
                    toggleState = grid[row][col] ? 0 : 1;
                    grid[row][col] = toggleState;
                    cellElement.classList.toggle('alive', toggleState === 1);
                });

                cellElement.addEventListener('mouseover', () => {
                    if (isMouseDown) {
                        grid[row][col] = toggleState;
                        cellElement.classList.toggle('alive', toggleState === 1);
                    }
                });

                cellElement.addEventListener('mouseup', () => {
                    isMouseDown = false;
                });

                gameElement.appendChild(cellElement);
            }
        }

        // Empêche le comportement par défaut du navigateur lors du glissement en dehors de la grille
        document.body.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // Fonction pour mettre à jour le DOM en fonction de la grille
        function updateDOM() {
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const cellElement = getCellElement(row, col);
                    if (grid[row][col] === 1) {
                        cellElement.classList.add('alive');
                    } else {
                        cellElement.classList.remove('alive');
                    }
                }
            }
        }

        // Obtenir la position d'une cellule dans la grille
        function getCellElement(row, col) {
            return gameElement.children[row * cols + col];
        }

        // Appliquer les règles du jeu de la vie
        function updateGridFunction() {
            let newGrid = grid.map(arr => [...arr]);

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const neighbors = countNeighbors(row, col);
                    if (grid[row][col] === 1) {
                        if (neighbors < 2 || neighbors > 3) {
                            newGrid[row][col] = 0;
                        }
                    } else {
                        if (neighbors === 3) {
                            newGrid[row][col] = 1;
                        }
                    }
                }
            }

            // Mettre à jour la grille et le DOM
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (grid[row][col] !== newGrid[row][col]) {
                        grid[row][col] = newGrid[row][col];
                        const cellElement = getCellElement(row, col);
                        if (grid[row][col] === 1) {
                            cellElement.classList.add('alive');
                        } else {
                            cellElement.classList.remove('alive');
                        }
                    }
                }
            }
        }

        // Compter les voisins vivants autour d'une cellule
        function countNeighbors(row, col) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const x = (row + i + rows) % rows;
                    const y = (col + j + cols) % cols;
                    count += grid[x][y];
                }
            }
            return count;
        }

        // Démarrer ou mettre en pause la simulation
        function startPauseGame() {
            if (!running) {
                intervalId = setInterval(updateGridFunction, 100);
                running = true;
                startPauseButton.textContent = 'Pause';
            } else {
                clearInterval(intervalId);
                running = false;
                startPauseButton.textContent = 'Démarrer';
            }
        }

        // Effacer la grille
        function clearGridFunction() {
            clearInterval(intervalId);
            running = false;
            startPauseButton.textContent = 'Démarrer';
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    grid[row][col] = 0;
                    const cellElement = getCellElement(row, col);
                    cellElement.classList.remove('alive');
                }
            }
        }

        // Fonction pour ajouter une glider gun
        function addGliderGun(startRow, startCol) {
            const gun = [
                [startRow, startCol + 24],
                [startRow + 1, startCol + 22],
                [startRow + 1, startCol + 24],
                [startRow + 2, startCol + 12],
                [startRow + 2, startCol + 13],
                [startRow + 2, startCol + 20],
                [startRow + 2, startCol + 21],
                [startRow + 2, startCol + 34],
                [startRow + 2, startCol + 35],
                [startRow + 3, startCol + 11],
                [startRow + 3, startCol + 15],
                [startRow + 3, startCol + 20],
                [startRow + 3, startCol + 21],
                [startRow + 4, startCol + 11],
                [startRow + 4, startCol + 15],
                [startRow + 4, startCol + 34],
                [startRow + 4, startCol + 35],
                [startRow + 5, startCol + 24],
                [startRow + 6, startCol + 22],
                [startRow + 6, startCol + 24],
                [startRow + 7, startCol + 12],
                [startRow + 7, startCol + 13],
                [startRow + 7, startCol + 20],
                [startRow + 7, startCol + 21],
                [startRow + 8, startCol + 12],
                [startRow + 8, startCol + 13],
                [startRow + 9, startCol + 24],
                [startRow + 10, startCol + 24],
                [startRow + 11, startCol + 24],
                [startRow + 12, startCol + 24],
                [startRow + 13, startCol + 24],
                [startRow + 14, startCol + 24]
            ];

            gun.forEach(([row, col]) => {
                if (row < rows && col < cols) {
                    grid[row][col] = 1;
                }
            });
        }

        // Fonction pour ajouter un glider
        function addGlider(startRow, startCol) {
            const glider = [
                [startRow, startCol + 1],
                [startRow + 1, startCol + 2],
                [startRow + 2, startCol],
                [startRow + 2, startCol + 1],
                [startRow + 2, startCol + 2]
            ];

            glider.forEach(([row, col]) => {
                if (row < rows && col < cols) {
                    grid[row][col] = 1;
                }
            });
        }

        // Fonction pour ajouter un oscillateur (Blinker)
        function addBlinker(startRow, startCol) {
            const blinker = [
                [startRow, startCol],
                [startRow, startCol + 1],
                [startRow, startCol + 2]
            ];

            blinker.forEach(([row, col]) => {
                if (row < rows && col < cols) {
                    grid[row][col] = 1;
                }
            });
        }

        // Fonction pour ajouter un motif complexe (Ordinateur simplifié)
        function addComputer(startRow, startCol) {
            // Pour simplifier, nous allons ajouter plusieurs composants de base
            addGliderGun(startRow, startCol);
            addGlider(startRow + 10, startCol + 10);
            addBlinker(startRow + 20, startCol + 20);
        }

        // Placement automatique des motifs au démarrage avec randomisation
        function placeInitialPattern() {
            // Effacer la grille avant de placer les motifs
            clearGridFunction();

            // Définir le nombre de composants à ajouter
            const numberOfComponents = 3;

            for (let i = 0; i < numberOfComponents; i++) {
                // Générer des positions aléatoires pour les composants
                const startRow = Math.floor(Math.random() * (rows - 30));
                const startCol = Math.floor(Math.random() * (cols - 30));

                // Sélectionner aléatoirement un type de composant
                const componentType = Math.floor(Math.random() * 3);

                switch (componentType) {
                    case 0:
                        addGliderGun(startRow, startCol);
                        break;
                    case 1:
                        addGlider(startRow, startCol);
                        break;
                    case 2:
                        addBlinker(startRow, startCol);
                        break;
                    default:
                        addGliderGun(startRow, startCol);
                }
            }

            updateDOM();
        }

        // Fonction de réinitialisation pour ajouter un ordinateur fonctionnel
        function resetComputer() {
            placeInitialPattern();
        }

        // Ajouter des écouteurs d'événements aux boutons
        startPauseButton.addEventListener('click', startPauseGame);
        clearButton.addEventListener('click', clearGridFunction);
        resetButton.addEventListener('click', resetComputer);

        // Placer les motifs initiaux et mettre à jour la grille
        placeInitialPattern();
    </script>

</body>
</html>
